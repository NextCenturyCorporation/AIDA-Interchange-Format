package edu.isi.gaia

import com.google.common.collect.ImmutableMultiset
import mu.KLogging
import org.apache.jena.datatypes.RDFDatatype
import org.apache.jena.graph.Graph
import org.apache.jena.graph.Triple
import org.apache.jena.rdf.model.*
import org.apache.jena.shared.Command
import org.apache.jena.shared.Lock
import org.apache.jena.shared.PrefixMapping
import org.apache.jena.tdb.TDBFactory
import org.apache.jena.vocabulary.RDF
import org.apache.jena.vocabulary.SKOS
import org.apache.jena.vocabulary.XSD
import java.io.InputStream
import java.io.OutputStream
import java.io.Reader
import java.io.Writer
import java.nio.charset.StandardCharsets.UTF_8
import java.nio.file.Paths
import java.util.*
import java.util.function.Supplier

/*
Converts ColdStart++ knowledge bases to the GAIA interchange format.

See main method for a description of the parameters expected.
 */

// these could be changed to darpa.mil if the interchange format is adopted program-wide
// TODO: temporarily extend these to include all ColdStart entity types - #2
// TODO: long-term, we need to make the program ontology configurable

object AidaSyntaxOntology {
    val _namespace: String = "http://www.isi.edu/aida/interchangeOntology#"

    // properties
    val SYSTEM = ResourceFactory.createProperty(_namespace + "system")!!
    val CONFIDENCE = ResourceFactory.createProperty(_namespace + "confidence")!!
    val CONFIDENCE_VALUE = ResourceFactory.createProperty(_namespace + "confidenceValue")!!
    val JUSTIFIED_BY = ResourceFactory.createProperty(_namespace + "justifiedBy")!!
    val SOURCE = ResourceFactory.createProperty(_namespace + "source")!!
    val START_OFFSET = ResourceFactory.createProperty(_namespace + "startOffset")!!
    val END_OFFSET_INCLUSIVE = ResourceFactory.createProperty(_namespace
            + "endOffsetInclusive")!!
    val LINK = ResourceFactory.createProperty(_namespace + "link")!!
    val LINK_TARGET = ResourceFactory.createProperty(_namespace + "linkTarget")!!

    // classes
    val TEXT_PROVENANCE = ResourceFactory.createProperty(_namespace + "TextProvenance")!!
    val LINK_ASSERTION = ResourceFactory.createProperty(_namespace + "LinkAssertion")!!
}

object AidaProgramOntology {
    val _namespace: String = "http://www.isi.edu/aida/programOntology#"
    val PERSON = ResourceFactory.createProperty(_namespace + "Person")!!
    val ORGANIZATION = ResourceFactory.createProperty(_namespace + "Organization")!!
    val LOCATION = ResourceFactory.createProperty(_namespace + "Location")!!
    val GPE = ResourceFactory.createProperty(_namespace + "GeopoliticalEntity")!!
    val FACILITY = ResourceFactory.createProperty(_namespace + "Facility")!!

}



interface NodeGenerator {
    /*
    A strategy for generating RDF graph nodes
     */
    fun nextNode(model:Model): Resource
}

class BlankNodeGenerator : NodeGenerator {
    /*
    A node generation strategy which always returns blank nodes.

    This is useful for testing because we don't need to coordinate entity, event, etc.
    URIs in order to test isomorphism between graphs.  At runtime, it avoids
    generating URIs for nodes which only need to be referred to once as part of a
    large structure (e.g. confidences)
    */
    override fun nextNode(model: Model): Resource {
        return model.createResource()
    }
}

class UUIDNodeGenerator(val baseURI: String) : NodeGenerator {
    /**
     *     A node generation strategy which uses UUIDs appended to a base URI.
      */

    init {
        require(baseURI.isNotEmpty()){ "Base URI cannot be empty"}
        require(!baseURI.endsWith("/")){ "Base URI cannot end in /"}
    }

    override fun nextNode(model: Model): Resource {
        return model.createResource(baseURI + '/' + UUID.randomUUID().toString())
    }
}

class ColdStart2GaiaConverter(val entityNodeGenerator: NodeGenerator = BlankNodeGenerator(),
                              val eventNodeGenerator: NodeGenerator = BlankNodeGenerator(),
                              val assertionNodeGenerator: NodeGenerator = BlankNodeGenerator()) {
    companion object: KLogging()

    /**
     * Concert a ColdStart KB to an RDFLib graph in the proposed AIDA interchange format.
     */

    fun coldstartToGaia(system_uri: String, cs_kb: ColdStartKB, destinationModel: Model) {
        return Conversion(system_uri, destinationModel).convert(cs_kb)
    }

    private inner class Conversion(val system_uri: String, val model: Model) {
        // stores a mapping of ColdStart objects to their URIs in the interchange format
        val object_to_uri = mutableMapOf<Any, Resource>()

        // this is the URI for the generating system
        val system_node = model.getResource(system_uri)

        // mark a triple as having been generated by this system
        fun associate_with_system(identifier: Resource) {
            identifier.addProperty(AidaSyntaxOntology.SYSTEM, system_node)
        }

        fun markSingleAssertionConfidence(reifiedAssertion: Resource, confidence: Double) {
            //  mark an assertion with confidence from this system
            val confidenceBlankNode = model.createResource()
            reifiedAssertion.addProperty(AidaSyntaxOntology.CONFIDENCE, confidenceBlankNode)
            confidenceBlankNode.addProperty(AidaSyntaxOntology.CONFIDENCE_VALUE,
                    model.createTypedLiteral(confidence))
            associate_with_system(confidenceBlankNode)
        }

        // converts a ColdStart object to an RDF identifier (node in the RDF graph)
        // if this ColdStart node has been previously converted, we return the same RDF identifier
        fun toResource(node: Node): Resource {
            if (!object_to_uri.containsKey(node)) {
                val rdfNode = when (node) {
                    is EntityNode -> entityNodeGenerator.nextNode(model)
                    is EventNode -> eventNodeGenerator.nextNode(model)
                    else -> throw RuntimeException("Cannot make a URI for " + node.toString())
                }
                object_to_uri.put(node, rdfNode)
            }
            return object_to_uri.getValue(node)
        }

        // converts a ColdStart ontology type to a corresponding RDF identifier
        // TODO: This is temporarily hardcoded but will eventually need to be configurable
        // @xujun: you will need to extend this hardcoding
        fun toOntologyType(ontology_type: String): Resource {
            return when (ontology_type) {
                "PER" -> AidaProgramOntology.PERSON
                "ORG" -> AidaProgramOntology.ORGANIZATION
                "LOC" -> AidaProgramOntology.LOCATION
                "FAC" -> AidaProgramOntology.FACILITY
                "GPE" -> AidaProgramOntology.GPE
                else -> throw RuntimeException("Unknown ontology type $ontology_type")
            }
        }

        // below are the functions for translating each individual type of ColdStart assertion
        // into the appropriate RDF structures
        // each will return a boolean specifying whether or not the conversion was successful

        // translate ColdStart type assertions
        fun translateType(cs_assertion: TypeAssertion, confidence: Double?): Boolean {
            require(confidence == null) {
                "Type assertions should not have confidences in " +
                        "ColdStart"
            }
            if (cs_assertion.subject is EntityNode) {
                val rdfAssertion = assertionNodeGenerator.nextNode(model)
                val entity = toResource(cs_assertion.subject)
                val ontology_type = toOntologyType(cs_assertion.type)
                rdfAssertion.addProperty(RDF.type, RDF.Statement)
                rdfAssertion.addProperty(RDF.subject, entity)
                rdfAssertion.addProperty(RDF.predicate, RDF.type)
                rdfAssertion.addProperty(RDF.`object`, ontology_type)
                associate_with_system(rdfAssertion)
                return true
            } else {
                return false
            }
        }

        // translate ColdStart entity mentions
        fun translateEntityMention(cs_assertion: EntityMentionAssertion, confidence: Double?)
                : Boolean {
            if (confidence == null) logger.warn { "Entity mention lacks confidence $cs_assertion" }

            val entityResource = toResource(cs_assertion.subject)
            associate_with_system(entityResource)
            // if this is a canonical mention, then we need to make a skos:preferredLabel triple
            if (cs_assertion.mention_type == CANONICAL_MENTION) {
                // TODO: because skos:preferredLabel isn't reified we can't attach info
                // on the generating system
                entityResource.addProperty(SKOS.prefLabel,
                        model.createTypedLiteral(cs_assertion.string))
            }

            for (justification in cs_assertion.justifications.predicate_justifications) {
                val justification_node = model.createResource()
                if (confidence != null) {
                    markSingleAssertionConfidence(justification_node, confidence)
                }
                associate_with_system(justification_node)
                justification_node.addProperty(RDF.type, AidaSyntaxOntology.TEXT_PROVENANCE)
                justification_node.addProperty(AidaSyntaxOntology.SOURCE,
                        model.createTypedLiteral(cs_assertion.justifications.doc_id))
                justification_node.addProperty(AidaSyntaxOntology.START_OFFSET,
                        model.createTypedLiteral(justification.start))
                justification_node.addProperty(AidaSyntaxOntology.END_OFFSET_INCLUSIVE,
                        model.createTypedLiteral(justification.end_inclusive))
                entityResource.addProperty(AidaSyntaxOntology.JUSTIFIED_BY, justification_node)

                // put mention string as the prefLabel of the justification
                justification_node.addProperty(SKOS.prefLabel,
                        model.createTypedLiteral(cs_assertion.string))
            }

            // TODO: handle translation of value-typed mentions-#7
            return true
        }

        // translate ColdStart link assertions
        fun translateLink(cs_assertion: LinkAssertion, confidence: Double?): Boolean {
            val entityResource = toResource(cs_assertion.subject)
            val linkAssertion = model.createResource()
            entityResource.addProperty(AidaSyntaxOntology.LINK, linkAssertion)
            // how do we want to handle links to external KBs ? currently we just store
            // them as strings
            linkAssertion.addProperty(AidaSyntaxOntology.LINK_TARGET,
                    model.createTypedLiteral(cs_assertion.global_id))
            if (confidence != null) {
                markSingleAssertionConfidence(linkAssertion, confidence)
            }

            return true
        }

        fun convert(csKB: ColdStartKB) {
            val untranslatableAssertionsB = ImmutableMultiset.builder<Class<Assertion>>()

            val progressInterval = 100000
            val numAssertions = csKB.allAssertions.size
            for ((assertionNum, assertion) in csKB.allAssertions.withIndex()) {
                // note not all ColdStart assertions have confidences
                val confidence = csKB.assertionsToConfidence[assertion]
                val translated = when (assertion) {
                    is TypeAssertion -> translateType(assertion, confidence)
                    is EntityMentionAssertion -> translateEntityMention(assertion, confidence)
                    is LinkAssertion -> translateLink(assertion, confidence)
                    else -> false
                }

                if (!translated) {
                    untranslatableAssertionsB.add(assertion.javaClass)
                }

                if (assertionNum % progressInterval == 0) {
                    logger.info { "Processed $assertionNum / $numAssertions assertions" }
                }
            }

            val untranslatableAssertions = untranslatableAssertionsB.build()

            if (!untranslatableAssertions.isEmpty()) {
                logger.warn("The following ColdStart assertions could not be translated: "
                        + untranslatableAssertions.toString())
            }

            model.setNsPrefix("rdf", RDF.uri)
            model.setNsPrefix("xsd", XSD.getURI())
            model.setNsPrefix("aida", AidaSyntaxOntology._namespace)
            model.setNsPrefix("aidaProgramOntology", AidaProgramOntology._namespace)
            model.setNsPrefix("skos", SKOS.uri)
        }
    }
}


fun main(args: Array<String>) {
    val inputKBFile = Paths.get(args[0])
    val outputRDFFile = Paths.get(args[1])
    val baseUri = "http://www.isi.edu"

    val coldstartKB = ColdStartKBLoader().load(inputKBFile)
    val converter = ColdStart2GaiaConverter(
            entityNodeGenerator = UUIDNodeGenerator(baseUri + "/entities"),
            eventNodeGenerator = UUIDNodeGenerator(baseUri + "/events"),
            assertionNodeGenerator = UUIDNodeGenerator(baseUri + "/assertions"))

    val tempDir = createTempDir()

    try {
        /*val dataset = TDBFactory.createDataset(tempDir.absolutePath)
        val model = dataset.defaultModel*/
        val model = DummyModel()

        converter.coldstartToGaia("http://www.rpi.edu/coldstart", coldstartKB, model)

        outputRDFFile.toFile().bufferedWriter(UTF_8).use { model.write(it, "TURTLE") }
    } finally {
        tempDir.deleteRecursively()
    }
}

/**


def main(params: Parameters) -> None:
"""
    A single YAML parameter file is expected as input.
    """
logging_utils.configure_logging_from(params)
# Coldstart KB is assumed to be gzip compressed
coldstart_kb_file = params.existing_file('input_coldstart_gz_file')
output_interchange_file = params.creatable_file('output_interchange_file')
# the URI to be used to identify the system which generated this ColdStart KB
system_uri = params.string('system_uri')
converter = ColdStartToGaiaConverter.from_parameters(params)

_log.info("Loading Coldstart KB from {!s}".format(coldstart_kb_file))
coldstart_kb = ColdStartKBLoader().load(
CharSource.from_gzipped_file(coldstart_kb_file, 'utf-8'))
_log.info("Converting ColdStart KB to RDF graph")
converted_graph = converter.convert_coldstart_to_gaia(system_uri, coldstart_kb)
_log.info("Serializing RDF graph in Turtle format to {!s}".format(output_interchange_file))
with open(output_interchange_file, 'wb') as out:
converted_graph.serialize(destination=out, format='turtle')


if __name__ == '__main__':
if len(sys.argv) == 2:
main(YAMLParametersLoader().load(Path(sys.argv[1])))
**/