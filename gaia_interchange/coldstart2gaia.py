"""
Converts ColdStart++ knowledge bases to the GAIA interchange format.
"""
import logging
import sys
from abc import ABCMeta, abstractmethod
from collections import defaultdict
from pathlib import Path
from typing import Dict, Any, MutableMapping, Optional, Union
from uuid import uuid4

from attr import attrs
from rdflib import Graph, URIRef, BNode, Literal, RDF
from rdflib.namespace import SKOS

from flexnlp.parameters import YAMLParametersLoader, Parameters
from flexnlp.utils.attrutils import attrib_instance_of
from flexnlp.utils.io_utils import CharSource
from flexnlp.utils.preconditions import check_arg, check_not_none
from flexnlp_sandbox.formats.tac.coldstart import ColdStartKB, ColdStartKBLoader, TypeAssertion, \
    EntityNode, Node, EventNode, EntityMentionAssertion, CANONICAL_MENTION, LinkAssertion
from gaia_interchange.aida_rdf_ontologies import AIDA_PROGRAM_ONTOLOGY, AIDA

_log = logging.getLogger(__name__)


class NodeGenerator(metaclass=ABCMeta):
    @abstractmethod
    def next_node(self) -> Union[URIRef, BNode]:
        raise NotImplementedError()


class BlankNodeGenerator(NodeGenerator):
    """
    A node generation strategy which always returns blank nodes.

    This is useful for testing because we don't need to coordinate entity, event, etc.
    URIs in order to test isomorphism between graphs.
    """
    def next_node(self) -> Union[URIRef, BNode]:
        return BNode()


@attrs(frozen=True)
class UUIDNodeGenerator(NodeGenerator):
    """
    A node generation strategy which uses UUIDs appended to a base URI
    """
    base_uri: str = attrib_instance_of(str)

    def next_node(self) -> Union[URIRef, BNode]:
        return URIRef(self.base_uri + '/' + str(uuid4()))


@attrs(frozen=True)
class ColdStartToGaiaConverter:
    entity_node_generator: NodeGenerator = attrib_instance_of(NodeGenerator,
                                                              default=BlankNodeGenerator())
    event_node_generator: NodeGenerator = attrib_instance_of(NodeGenerator,
                                                             default=BlankNodeGenerator())
    assertion_node_generator: NodeGenerator = attrib_instance_of(NodeGenerator,
                                                                 default=BlankNodeGenerator())

    def convertColdStartToGaia(self, system_uri: str, cs_kb: ColdStartKB)-> Graph:
        # stores a mapping of coldstart objects to their URIs in the interchange format
        object_to_uri: Dict[Any, Union[BNode, URIRef]] = dict()

        # this is the URI for the generating system
        system_node = URIRef(system_uri)

        # mark a triple as having been generated by this system
        def associate_with_system(reified_assertion) -> None:
            g.add((reified_assertion, AIDA.system, system_node))

        # mark an assertion with confidence from this system
        def mark_single_assertion_confidence(reified_assertion, confidence: float) -> None:
            confidence_blank_node = BNode()
            g.add((reified_assertion, AIDA.confidence, confidence_blank_node))
            g.add((confidence_blank_node, AIDA.confidenceValue, Literal(confidence)))
            g.add((confidence_blank_node, AIDA.system, system_node))

        def to_uri(node: Node) -> URIRef:
            check_arg(isinstance(node, EntityNode))
            if node not in object_to_uri:
                if isinstance(node, EntityNode):
                    uri = self.entity_node_generator.next_node()
                elif isinstance(node, EventNode):
                    uri = self.event_node_generator.next_node()
                else:
                    raise NotImplementedError("Cannot make a URI for {!s}".format(node))
                object_to_uri[node] = uri
            return object_to_uri[node]

        def to_ontology_type(ontology_type: str) -> URIRef:
            if ontology_type == "PER":
                return AIDA_PROGRAM_ONTOLOGY.Person
            elif ontology_type == "ORG":
                return AIDA_PROGRAM_ONTOLOGY.Organization
            else:
                raise NotImplementedError("Cannot interpret ontology type " + ontology_type)

        def _translate_type(g: Graph, cs_assertion: TypeAssertion, confidence: Optional[float]) \
                -> bool:
            check_arg(confidence is None, "Type assertions should not have confidences in "
                                          "ColdStart")
            if isinstance(assertion.sbj, EntityNode):
                rdf_assertion = self.assertion_node_generator.next_node()
                entity = to_uri(cs_assertion.sbj)
                ontology_type = to_ontology_type(cs_assertion.obj)
                g.add((rdf_assertion, RDF.subject, entity))
                g.add((rdf_assertion, RDF.predicate, RDF.type))
                g.add((rdf_assertion, RDF.object, ontology_type))
                associate_with_system(rdf_assertion)
                return True
            else:
                # TODO: handle events, etc.
                return False

        def _translate_entity_mention(g: Graph, cs_assertion: EntityMentionAssertion,
                                      confidence: Optional[float]) -> bool:
            check_not_none(confidence)
            entity_uri = to_uri(assertion.sbj)
            associate_with_system(entity_uri)
            # if this is a canonical mention, then we need to make a skos:preferredLabel triple
            if cs_assertion.type == CANONICAL_MENTION:
                # TODO: because skos:preferredLabel isn't reified we can't attach info
                # on the generating system
                g.add((entity_uri, SKOS.prefLabel, Literal(cs_assertion.obj)))
            # TODO: incorporate mention strings as part of the vector associated with
            # provenances : #6
            for justification in cs_assertion.justifications.predicate_justifications:
                justification_node = BNode()
                mark_single_assertion_confidence(justification_node, confidence)
                associate_with_system(justification_node)

                g.add((justification_node, RDF.type, AIDA.TextProvenance))
                g.add((justification_node, AIDA.source, Literal(
                    cs_assertion.justifications.doc_id)))
                g.add((justification_node, AIDA.startOffset, Literal(justification.start)))
                # +1 because Span end is exclusive but interchange format is inclusive
                g.add((justification_node, AIDA.endOffsetInclusive, Literal(justification.end + 1)))
                g.add((entity_uri, AIDA.justifiedBy, justification_node))

                # put mention string as the prefLabel of the justification
                g.add((justification_node, SKOS.prefLabel, Literal(cs_assertion.obj)))

            # TODO: handle translation of value-typed mentions - #7
            return True

        def _translate_link(g: Graph, cs_assertion: LinkAssertion,
                            confidence: Optional[float]) -> bool:
            entity_uri = to_uri(cs_assertion.sbj)
            link_assertion = BNode()
            g.add((entity_uri, AIDA.link, link_assertion))
            # how do we want to handle links to external KBs? currently we just store
            # them as strings
            g.add((link_assertion, AIDA.linkTarget, Literal(cs_assertion.global_id)))
            if confidence is not None:
                confidence_node = BNode()
                g.add((link_assertion, AIDA.confidence, confidence_node))
                g.add((confidence_node, AIDA.confidenceValue, Literal(confidence)))

            return True

        assertions_to_translator = { TypeAssertion : _translate_type,
                                     EntityMentionAssertion : _translate_entity_mention,
                                     LinkAssertion: _translate_link}

        untranslatable_assertions: MutableMapping[str, int] = defaultdict(int)

        # this is what will be serialized as our final output
        g = Graph()

        for assertion in cs_kb.all_assertions:
            confidence = cs_kb.assertions_to_confidences.get(assertion, None)
            assertion_translator = assertions_to_translator.get(assertion.__class__, None)
            if not (assertion_translator and assertion_translator(g, assertion, confidence)):
                untranslatable_assertions[str(assertion.__class__)] += 1

        if untranslatable_assertions:
            _log.warning("The following ColdStart assertions could not be translated: {!s}".format(
                untranslatable_assertions))

        g.namespace_manager.bind('aida', AIDA)
        g.namespace_manager.bind('aidaProgramOntology', AIDA_PROGRAM_ONTOLOGY)
        g.namespace_manager.bind('skos', SKOS)

        return g


def main(params: Parameters) -> None:
    coldstart_kb_file = params.existing_file('input_coldstart_file')
    output_interchange_file = params.creatable_file('output_interchange_file')
    system_uri = params.string('system_uri')

    _log.info("Converting {!s} from ColdStart KB format to GAIA interchange format and "
              "writing it to {!s}".format(coldstart_kb_file, output_interchange_file))

    converted_graph = ColdStartToGaiaConverter().convertColdStartToGaia(
        system_uri, ColdStartKBLoader().load(
            CharSource.from_gzipped_file(coldstart_kb_file, 'utf-8')))
    with open(output_interchange_file, 'wb') as out:
        converted_graph.serialize(destination=out, format='turtle')


if __name__ == '__main__':
    if len(sys.argv) == 2:
        main(YAMLParametersLoader().load(Path(sys.argv[1])))
